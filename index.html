<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>


  <title> Hexo </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            Schedule
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/18/js_面向对象编程/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2018-05-18T22:44:33+08:00" content="2018-05-18">
              2018-05-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##面向对象编程</p>
<p>概述：</p>
<p>不过，在JavaScript中，这个概念需要改一改。JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>
<p>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。<br>如：xiaoming.__proto__ = Student;<br>在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming</p>
<pre><code>// 原型对象:
var Student = {
    name: &apos;Robot&apos;,
    height: 1.2,
    run: function () {
        console.log(this.name + &apos; is running...&apos;);
    }
};

function createStudent(name) {
    // 基于Student原型创建一个新对象:
    var s = Object.create(Student);
    // 初始化新对象:
    s.name = name;
    return s;
}

var xiaoming = createStudent(&apos;小明&apos;);
xiaoming.run(); // 小明 is running...
xiaoming.__proto__ === Student; // true
</code></pre><p>###创建对象(每个对象都设置一个原型，指向它的原型对象)<br>当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。</p>
<p>如：创建于一个Array对象：var arr = [1, 2, 3];<br>其原型链是：<figure class="highlight plain"><figcaption><span>----> Array.prototype ----> Object.prototype ----> null```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如，当我们创建一个函数时：</span><br><span class="line"></span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">函数也是一个对象，它的原型链是：```foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">注：（原型链以上的是简易写法,关于proto 和prototype详细内容见下文）</span><br><span class="line"></span><br><span class="line">1.每个对象都有\_proto_属性，如函数的prototype 其为对象 内也含有\_proto_属性</span><br><span class="line"></span><br><span class="line">2.首先来说说prototype属性，不像每个对象都有\__proto\__属性来标识自己所继承的原型，只有函数才有prototype属性。当你创建函数时，JS会为这个函数自动添加prototype属性，值是一个有 constructor 属性的对象，不是空对象。而一旦你把这个函数当作构造函数（constructor）调用（即通过new关键字调用），那么JS就会帮你创建该构造函数的实例，实例继承构造函数prototype的所有属性和方法（实例通过设置自己的\__proto\__指向构造函数的prototype来实现这种继承）。</span><br><span class="line"></span><br><span class="line">prototype属性 （包含constructor 、因为是函数也是对象 所以也有\_proto_属性</span><br><span class="line">总结：</span><br><span class="line">对象的\__proto\__指向自己构造函数的prototype。obj.\__proto\__.\__proto\__...的原型链由此产生，包括我们的操作符instanceof正是通过探测obj.\__proto\__.\__proto\__... === Constructor.prototype来验证obj是否是Constructor的实例。</span><br><span class="line"></span><br><span class="line">回到开头的代码，two = new Object()中Object是构造函数，所以two.\__proto\__就是Object.prototype。至于one，ES规范定义对象字面量的原型就是Object.prototype。</span><br><span class="line"></span><br><span class="line">[* 详细可看此文章,用Issues写blog也是没谁了](https://github.com/creeperyang/blog/issues/9)</span><br></pre></td></tr></table></figure>
<p>####构造函数</p>
<pre><code>function Student(name) {
    this.name = name;
    this.hello = function () {
        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);
    }
}
</code></pre><p>采用此种方式：<br>这是一个普通函数，但是在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象：</p>
<pre><code>var xiaoming = new Student(&apos;小明&apos;);
xiaoming.name; // &apos;小明&apos;
xiaoming.hello(); // Hello, 小明!
</code></pre><p>function Student(props) {<br>    this.name = props.name || ‘匿名’; // 默认值为’匿名’<br>    this.grade = props.grade || 1; // 默认值为1<br>}</p>
<p>Student.prototype.hello = function () {<br>    alert(‘Hello, ‘ + this.name + ‘!’);<br>};</p>
<p>function createStudent(props) {<br>    return new Student(props || {})<br>}</p>
<p>调用：<br>var xiaoming = createStudent({<br>    name: ‘小明’<br>});</p>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><p>function PrimaryStudent(props) {<br>    // 调用Student构造函数，绑定this变量:<br>    Student.call(this, props);<br>    this.grade = props.grade || 1;<br>}<br>但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Object.prototype ----&gt; null
</code></pre><p>必须想办法把原型链修改为：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null
</code></pre><p>中间对象可以用一个空函数F来实现</p>
<pre><code>// PrimaryStudent构造函数:
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 空函数F:
function F() {
}

// 1。把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 2.把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 3.把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};

// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: &apos;小明&apos;,
    grade: 2
});
xiaoming.name; // &apos;小明&apos;
xiaoming.grade; // 2

// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true

// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true
</code></pre><p>注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。（没用F的构造函数，各用个的构造函数）</p>
<p>如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码：</p>
<pre><code>function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}

function Student(props) {
    this.name = props.name || &apos;Unnamed&apos;;
}

Student.prototype.hello = function () {
    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};
</code></pre><p>####class继承（ES6）</p>
<p>class写法：</p>
<pre><code>//旧
function Student(name) {
    this.name = name;
}
Student.prototype.hello = function () {
    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);
}
 // 新
class Student {
    constructor(name) {
        this.name = name;
    }

    hello() {
        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);
    }
}
</code></pre><p>继承写法</p>
<pre><code>class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert(&apos;I am at grade &apos; + this.grade);
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/18/js_函数/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2018-05-18T22:44:20+08:00" content="2018-05-18">
              2018-05-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##函数</p>
<p>###1.函数定义和调用</p>
<p>####1.1 定义方式：<br>第一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function abs(x) &#123;</span><br><span class="line">    if (x &gt;= 0) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。</p>
<p>第二种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var abs = function (x) &#123;</span><br><span class="line">    if (x &gt;= 0) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这种方式下，function (x) { … }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。</p>
<p>上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。</p>
<p>#####1.2 调用方式（传参方式）：<br>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题。不传也没问题。undefined 返回NaN，为避免参数类型不匹配，可以在传入时候判断类型。</p>
<p>####1.3 arguments<br>JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> function abs() &#123;</span><br><span class="line">        if (arguments.length === 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        var x = arguments[0];</span><br><span class="line">        return x &gt;= 0 ? x : -x;</span><br><span class="line">    &#125;</span><br><span class="line">abs(); // 0</span><br><span class="line">abs(10); // 10</span><br><span class="line">abs(-9); //</span><br></pre></td></tr></table></figure></p>
<p>####1.4 rest参数 用来存储多余的参数（ES6）<br>    ES6引入<br>    function sum(…rest) {<br>       ???<br>    }</p>
<p>###2 变量作用域</p>
<p>####2.1 var的作用域：JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</p>
<ul>
<li>如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量</li>
<li>不同函数内部的同名变量互相独立，互不影响：</li>
<li>函数嵌套函数，内部函数能访问外部函数的变量，反之外部部能访问内部函数。</li>
<li>如果内部函数和外部函数的变量名重名\ （函数名重名 调用重外向内调用函数）</li>
</ul>
<p>####2.2 变量提升<br>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：因此最好先声明函数内部用到的所有变量。</p>
<p>####2.3 全局作用域<br>JS有个默认的对象window 全局作用域的变量；实际被绑定到window的一个属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">var course = &apos;Learn JavaScript&apos;;</span><br><span class="line">alert(course); // &apos;Learn JavaScript&apos;</span><br><span class="line">alert(window.course); // &apos;Learn JavaScript&apos;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    alert(&apos;foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); // 直接调用foo()</span><br><span class="line">window.foo(); // 通过window.foo()调用</span><br></pre></td></tr></table></figure></p>
<p>你可能猜到了，由于函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，<em>因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象.</em><br>这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。</p>
<p>####2.4 名字空间<br>全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中<br>    // 唯一的全局变量MYAPP:<br>    var MYAPP = {};</p>
<pre><code>// 其他变量:
MYAPP.name = &apos;myapp&apos;;
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return &apos;foo&apos;;
};
</code></pre><p>####2.5 局部作用域（ES6）<br>由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的 。</p>
<p>为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：</p>
<pre><code>&apos;use strict&apos;;

function foo() {
    var sum = 0;
    for (let i=0; i&lt;100; i++) {
        sum += i;
    }
    // SyntaxError:
    i += 1;
}
</code></pre><p>####2.6 常量（ES6）<br>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：<br>const PI = 3.14;</p>
<p>####2.7 解构赋值（ES6）<br>从ES6开始，JavaScript引入了解构赋值，可以同时对一组（多个）变量进行赋值。<br>例如：给x、y、z赋值</p>
<pre><code>旧的赋值方式：
var array = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;];
var x = array[0];
var y = array[1];
var z = array[2];

新的赋值方式：
&apos;use strict&apos;;
var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;];
</code></pre><blockquote>
<p>其他方式：</p>
<p>嵌套赋值：</p>
<pre><code>let [x, [y, z]] = [&apos;hello&apos;, [&apos;JavaScript&apos;, &apos;ES6&apos;]];
x; // &apos;hello&apos;
y; // &apos;JavaScript&apos;
z; // &apos;ES6&apos;
</code></pre><p>缺省赋值：</p>
<pre><code>let [, , z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;]; // 忽略前两个元素，只对z赋值第三个元素
</code></pre><p>对象赋值：</p>
<pre><code>&apos;use strict&apos;;
var person = {
    name: &apos;小明&apos;,
    age: 20,
    gender: &apos;male&apos;,
    passport: &apos;G-12345678&apos;,
    school: &apos;No.4 middle school&apos;
};
var {name, age, passport} = person;
</code></pre><p>变量名和属性不一致赋值：</p>
<pre><code>var person = {
    name: &apos;小明&apos;,
    age: 20,
    gender: &apos;male&apos;,
    passport: &apos;G-12345678&apos;,
    school: &apos;No.4 middle school&apos;
};
// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // &apos;小明&apos;
id; // &apos;G-12345678&apos;
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined
</code></pre><p>默认赋值</p>
<pre><code>var person = {
    name: &apos;小明&apos;,
    age: 20,
    gender: &apos;male&apos;,
    passport: &apos;G-12345678&apos;
};
// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
name; // &apos;小明&apos;
single; // true
</code></pre><p>特殊情况：</p>
<pre><code>有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：
// 声明变量:
var x, y;
// 解构赋值:
{x, y} = { name: &apos;小明&apos;, x: 100, y: 200};
// 语法错误: Uncaught SyntaxError: Unexpected token =
这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：

({x, y} = { name: &apos;小明&apos;, x: 100, y: 200});
</code></pre></blockquote>
<p>使用场景</p>
<ul>
<li>交换xy的值<pre><code>var x=1, y=2;
[x, y] = [y, x]
</code></pre></li>
<li><p>快速获取当前页面的域名和路径：</p>
<pre><code>var {hostname:domain, pathname:path} = location;
</code></pre></li>
<li><p>快速创建对象</p>
<pre><code>function buildDate({year, month, day, hour=0, minute=0, second=0}) {
    return new Date(year + &apos;-&apos; + month + &apos;-&apos; + day + &apos; &apos; + hour + &apos;:&apos; + minute + &apos;:&apos; + second);
}
buildDate({ year: 2017, month: 1, day: 1 });
// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)
</code></pre></li>
</ul>
<p>###3 方法（在一个对象中绑定函数，称为这个对象的方法。）<br>    var xiaoming = {<br>        name: ‘小明’,<br>        birth: 1990,<br>        age: function () {<br>            var y = new Date().getFullYear();<br>            return y - this.birth;<br>        }<br>    };</p>
<pre><code>xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
</code></pre><p>####3.1 this作用域问题</p>
<p>该函数的this指向被调用的对象，在函数内 嵌套函数 是undefined 非strict指向window 、 函数本身（正确）、window。<br>解决方式：</p>
<p>给内嵌的函数指明this</p>
<pre><code>&apos;use strict&apos;;

var xiaoming = {
    name: &apos;小明&apos;,
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // 25
</code></pre><p>用apply和call 来指明this指向</p>
<pre><code>function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: &apos;小明&apos;,
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
</code></pre><p>call()与apply（）的区别是：apply()把参数打包成Array再传入；call()把参数按顺序传入。</p>
<pre><code>Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5
</code></pre><p>对普通函数调用，我们通常把this绑定为null。</p>
<p>用apply做装饰器，给函数扩展功能<br>统计parseInt被调用的次数</p>
<pre><code>&apos;use strict&apos;;

var count = 0;
var oldParseInt = parseInt; // 保存原函数

window.parseInt = function () {
    count += 1;
    return oldParseInt.apply(null, arguments); // 调用原函数
};
</code></pre><p>###高阶函数（函数的参数为函数的函数）参数有函数  —接受或者返回一个函数的函数称为高阶函数</p>
<p>####map 转化</p>
<pre><code>function pow(x){return x * x;}
var array = [1,2,3];
var result = array.map(pow)
</code></pre><p>####reduce<br>reduce()传入两个参数然后，把第一次计算结果继续和序列的下一个元素做累积计算，其效果就是</p>
<pre><code>[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
</code></pre><p>例如 求和</p>
<pre><code>var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25
</code></pre><p>求积：</p>
<pre><code>var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * y;
}); // 25
</code></pre><p>要把[1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场：</p>
<pre><code>var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579
</code></pre><p>可累计计算的结果，可选择通过此函数处理。</p>
<p>####filter<br>和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</p>
<pre><code>var arr = [1, 2, 4, 5, 6, 9, 10, 15];
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
</code></pre><p>回调函数<br>filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身</p>
<pre><code>var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];
var r = arr.filter(function (element, index, self) {
    console.log(element); // 依次打印&apos;A&apos;, &apos;B&apos;, &apos;C&apos;
    console.log(index); // 依次打印0, 1, 2
    console.log(self); // self就是变量arr
    return true;
});
</code></pre><p>去除重复元素    return self.indexOf(element) === index; ？</p>
<p>####sort</p>
<pre><code>var arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
if (x &lt; y) {
    return 1;
}
if (x &gt; y) {
    return -1;
}
return 0;
}); // [20, 10, 2, 1]
</code></pre><p>x&lt;y 1 大的在前， x &lt; y -1 小的在前</p>
<p>统一大小写后再排序</p>
<p>####闭包（可以保留局部变量不被释放的代码块，被称为一个闭包）</p>
<p>不立即求和 而是返回求和函数：</p>
<pre><code>function lazy_sum(arr) {
    var sum = function () {
        return arr.reduce(function (x, y) {
            return x + y;
        });
    }
    return sum;
}
</code></pre><p>var f = lazy_sum([1,2,3,,4,5]);<br>f();//15 此时才真正计算和的结果</p>
<p>在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code>function count() {
    var arr = [];
    for (var i=1; i&lt;=3; i++) {
        arr.push((function (n) {
            return function () {
                return n * n;
            }
        })(i));
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];

f1(); // 1
f2(); // 4
f3(); // 9
</code></pre><blockquote>
<p>注意这里用了一个“创建一个匿名函数并立刻执行”的语法：<br>(function (x) {<br>    return x * x;<br>})(3); // 9<br>理论上讲，创建一个匿名函数并立刻执行可以这么写：</p>
<p>function (x) { return x <em> x } (3);<br>但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：<br>(function (x) { return x </em> x }) (3);<br> 通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：<br>    (function (x) {<br>        return x * x;<br>    })(3);</p>
</blockquote>
<p>闭包的作用：</p>
<p>换句话说，闭包其实就是创造出了一些函数私有的 ”持久化变量“。</p>
<p>所以从这个例子，我们可以总结出，闭包的创造条件是：</p>
<ul>
<li>存在内、外两层函数</li>
<li>内层函数对外层函数的局部变量进行了引用</li>
</ul>
<pre><code>闭包的主要用途：就是可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等等

闭包的弊端持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。
</code></pre><p>####Arrow Function（箭头函数) ES6<br>1.包含多条语句</p>
<pre><code>x =&gt; {
    if (x &gt; 0) {
        return x * x;
    }
    else {
        return - x * x;
    }
}
</code></pre><p>2.如果参数不是一个，就需要用括号()括起来：</p>
<pre><code>// 两个参数:
(x, y) =&gt; x * x + y * y

// 无参数:
() =&gt; 3.14

// 可变参数:
(x, y, ...rest) =&gt; {
    var i, sum = x + y;
    for (i=0; i&lt;rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
</code></pre><p>3.如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：x =&gt; { foo: x } // SyntaxError:</p>
<pre><code>因为和函数体的{ ... }有语法冲突，所以要改为：x =&gt; ({ foo: x })
</code></pre><p>4.this</p>
<pre><code>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：**箭头函数内部的this是词法作用域**，由上下文确定。

var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25
</code></pre><ul>
<li>就不用使用var that  =this；这种写法了</li>
<li><p>由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：</p>
<pre><code>var obj = {
    birth: 1990,
    getAge: function (year) {
        var b = this.birth; // 1990
        var fn = (y) =&gt; y - this.birth; // this.birth仍是1990
        return fn.call({birth:2000}, year);
    }
};
obj.getAge(2015); // 25
</code></pre></li>
</ul>
<p>#####generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。</p>
<pre><code>function* fib(max) {
    var
        t,
        a = 0,
        b = 1,
        n = 0;
    while (n &lt; max) {
        yield a;
        [a, b] = [b, a + b];
        n ++;
    }
    return;
}


//第一种 执行
var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
//第二种执行
for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/18/js_对象/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2018-05-18T22:44:17+08:00" content="2018-05-18">
              2018-05-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##对象（在JavaScript的世界里，一切都是对象）</p>
<p>###1.标准对象<br>   typeof 获取对象类型</p>
<pre><code>typeof 123; // &apos;number&apos;
typeof NaN; // &apos;number&apos;
typeof &apos;str&apos;; // &apos;string&apos;
typeof true; // &apos;boolean&apos;
typeof undefined; // &apos;undefined&apos;
typeof Math.abs; // &apos;function&apos;
typeof null; // &apos;object&apos;
typeof []; // &apos;object&apos;
typeof {}; // &apos;object&apos;
</code></pre><p>####包装对象</p>
<p>number 、boolean、string都有包装对象类似于Java</p>
<pre><code>var n = new Number(123); // 123,生成了新的包装类型
var b = new Boolean(true); // true,生成了新的包装类型
var s = new String(&apos;str&apos;); // &apos;str&apos;,生成了新的包装类型
</code></pre><p>如果没有写new</p>
<pre><code>var n = Number(&apos;123&apos;); // 123，相当于parseInt()或parseFloat()
typeof n; // &apos;number&apos;

var b = Boolean(&apos;true&apos;); // true
typeof b; // &apos;boolean&apos;

var b2 = Boolean(&apos;false&apos;); // true! &apos;false&apos;字符串转换结果为true！因为它是非空字符串！
var b3 = Boolean(&apos;&apos;); // false

var s = String(123.45); // &apos;123.45&apos;
typeof s; // &apos;string&apos;
</code></pre><p>总结一下，有这么几条规则需要遵守：</p>
<ul>
<li><p>不要使用new Number()、new Boolean()、new String()创建包装对象；</p>
</li>
<li><p>用parseInt()或parseFloat()来转换任意类型到number；</p>
</li>
<li><p>用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；</p>
</li>
<li><p>通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；</p>
</li>
<li><p>typeof操作符可以判断出number、boolean、string、function和undefined；</p>
</li>
<li><p>判断Array要使用Array.isArray(arr)；</p>
</li>
<li><p>判断null请使用myVar === null；</p>
</li>
<li><p>判断某个全局变量是否存在用typeof window.myVar === ‘undefined’；</p>
</li>
<li><p>函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。</p>
</li>
</ul>
<pre><code>null虽然为obejct类型 但是没有toString方法,undeifined也没有toString方法。
number toString 用 123..toString() (123).toString()
</code></pre><p>####Date<br>要获取系统当前时间，用：</p>
<pre><code>var now = new Date();
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
</code></pre><p>创建指定日期：<br>    方法一：</p>
<pre><code>var d = new Date(2015,5,19,20,15,30,123)
d;
</code></pre><p>解析一个复合IOS 8601格式的字符串：得到一个时间戳<br>方法二：</p>
<pre><code>var d = Date.parse(&apos;2015-06-24T19:49:22.875+08:00&apos;);
d; // 1435146562875

var date = new Date(1435146562875);
d;
d.getMonth();
</code></pre><p>注意：</p>
<pre><code>JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。

时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。通过传递时间戳浏览器算出时间。
var = dc Data.now();//1435146562875
var d = new Date(dc);
d.toLocaleString(); // &apos;2015/6/24 下午7:49:22&apos;，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关
d.toUTCString(); // &apos;Wed, 24 Jun 2015 11:49:22 GMT&apos;，UTC时间，与本地时间相差8小时
</code></pre><p>####RegExp 正则表达式<br>匹配规则：</p>
<ul>
<li>\d 一个数字</li>
<li>\W一个字母或数字</li>
<li><p>. 一个任意字符（字母或者数字）</p>
</li>
<li><p>+ 至少一个</p>
</li>
<li>？0或者1个</li>
<li>* 任意个（包括0个）</li>
<li>{n,m}n-m个</li>
<li>\s 为空格</li>
</ul>
<pre><code>例子：\d{3}\s+\d{3,8}
我们来从左到右解读一下：

\d{3}表示匹配3个数字，例如&apos;010&apos;；

\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配&apos; &apos;，&apos;\t\t&apos;等；

\d{3,8}表示3-8个数字，例如&apos;1234567&apos;。
</code></pre><p>进阶规则：<br>要做更精确地匹配，可以用[]表示范围，比如：</p>
<ul>
<li>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线</li>
<li>[0-9a-zA-Z_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如’a100’，’0_Z’，’js2015’等等；</li>
<li>[a-zA-Z_\$][0-9a-zA-Z_\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；</li>
<li><p>[a-zA-Z_\$][0-9a-zA-Z_\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</p>
</li>
<li><p>a|b 可以匹配a或b</p>
</li>
<li>^表示行的开头  <em>如：^\d表示必须以数字开头。</em></li>
<li>$表示行的结尾 <em>如：\d$表示必须以数字结束。</em></li>
</ul>
<p>调用方法：</p>
<pre><code>var re1 = /ABC\-001/;
var re2 = new RegExp(&apos;ABC\\-001&apos;); //注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\\实际上是一个\。

re1; // /ABC\-001/
re2; // /ABC\-001/
</code></pre><p>功能：<br>1.切分字符串：<code>&#39;a,b;; c  d&#39;.split(/[\s\,\;]+/); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code><br>2.分组<br>提取子串的强大功能。用()表示的就是要提取的分组（Group）。<br>^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<pre><code>var re = /^(\d{3})-(\d{3,8})$/;
re.exec(&apos;010-12345&apos;); // [&apos;010-12345&apos;, &apos;010&apos;, &apos;12345&apos;]
re.exec(&apos;010 12345&apos;); // null
</code></pre><p>3.贪婪匹配<br>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符</p>
<p>var re = /^(\d+)(0*)$/;<br>re.exec(‘102300’); // [‘102300’, ‘102300’, ‘’]</p>
<p>由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。</p>
<p>必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：</p>
<p>var re = /^(\d+?)(0*)$/;<br>re.exec(‘102300’); // [‘102300’, ‘1023’, ‘00’]</p>
<p>4.全局搜索</p>
<p>JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配：</p>
<p>var r1 = /test/g;<br>// 等价于:<br>var r2 = new RegExp(‘test’, ‘g’);</p>
<p>全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引：</p>
<pre><code>var s = &apos;JavaScript, VBScript, JScript and ECMAScript&apos;;
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // [&apos;JavaScript&apos;]
re.lastIndex; // 10

re.exec(s); // [&apos;VBScript&apos;]
re.lastIndex; // 20

re.exec(s); // [&apos;JScript&apos;]
re.lastIndex; // 29

re.exec(s); // [&apos;ECMAScript&apos;]
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
</code></pre><p>全局匹配类似<em>搜索</em>，因此不能使用/^…$/，那样只会最多匹配一次。</p>
<p>正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。</p>
<p>###JSON</p>
<ul>
<li>number：和JavaScript的number完全一致；</li>
<li>boolean：就是JavaScript的true或false；</li>
<li>string：就是JavaScript的string；</li>
<li>null：就是JavaScript的null；</li>
<li>array：就是JavaScript的Array表示方式——[]；</li>
<li>object：就是JavaScript的{ … }表示方式。</li>
</ul>
<p>JSON还定死了字符集必须是UTF-8，</p>
<p>####序列化：</p>
<pre><code>&apos;use strict&apos;;

var xiaoming = {
    name: &apos;小明&apos;,
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    &apos;middle-school&apos;: &apos;\&quot;W3C\&quot; Middle School&apos;,
    skills: [&apos;JavaScript&apos;, &apos;Java&apos;, &apos;Python&apos;, &apos;Lisp&apos;]
};
var s =  JSON.stringify(xiaoming);
JSON.stringify(xiaoming, null, &apos;  &apos;);//按缩进输出
JSON.stringify(xiaoming, [&apos;name&apos;, &apos;skills&apos;], &apos;  &apos;);//输出指定的属性，可以传入Array
</code></pre><p>  还可以传入一个函数，这样对象的每个键值对都会被函数先处理：</p>
<pre><code>function convert(key, value) {
    if (typeof value === &apos;string&apos;) {
        return value.toUpperCase();
    }
    return value;
}

JSON.stringify(xiaoming, convert, &apos;  &apos;);
</code></pre><p>如果我们还想要精确控制如何序列化小明，可以给xiaoming定义一个toJSON()的方法，直接返回JSON应该序列化的数据：</p>
<pre><code>var xiaoming = {
    name: &apos;小明&apos;,
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    &apos;middle-school&apos;: &apos;\&quot;W3C\&quot; Middle School&apos;,
    skills: [&apos;JavaScript&apos;, &apos;Java&apos;, &apos;Python&apos;, &apos;Lisp&apos;],
    toJSON: function () {
        return { // 只输出name和age，并且改变了key：
            &apos;Name&apos;: this.name,
            &apos;Age&apos;: this.age
        };
    }
};

JSON.stringify(xiaoming); // &apos;{&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14}&apos;
</code></pre><p>####反序列化<br>拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象：</p>
<pre><code>JSON.parse(&apos;[1,2,3,true]&apos;); // [1, 2, 3, true]
JSON.parse(&apos;{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14}&apos;); // Object {name: &apos;小明&apos;, age: 14}
JSON.parse(&apos;true&apos;); // true
JSON.parse(&apos;123.45&apos;); // 123.45
</code></pre><p>JSON.parse()还可以接收一个函数，用来转换解析出的属性：</p>
<pre><code>var obj = JSON.parse(&apos;{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14}&apos;, function (key, value) {
    if (key === &apos;name&apos;) {
        return value + &apos;同学&apos;;
    }
    return value;
});
console.log(JSON.stringify(obj)); // {name: &apos;小明同学&apos;, age: 14}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/16/3.4_version_note/" itemprop="url">
                  3.4版本开发记录
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-16T15:46:17+08:00" content="2016-03-16">
              2016-03-16
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.2016.3.21 期间，恰逢bird小伙伴家父有恙来京检查身体。重新进行，开发计划安排，重新排期，重新制定开发计划。<br>协同IOS、后台、产品、设计们，调控开发进度。</p>
<p>2.2016.3.22<br>在只有需求、原型图的情况下，我开始了3.4版本的开发。<br>今天的目的，在无支付效果图情形下，首先进行，模块搭建，走通安卓支付流程。</p>
<p>同时研究，Dragger2的依赖注入。<br>A类中用到了B类，现在我们知道依赖注入是什么了，也就知道要怎么在代码中应用依赖注入了，所以我们就看看在我们的构造方法或者调用的方法中需要传递哪些依赖把。对于一些简单的依赖，这部分工作确实很好完成，但依赖越复杂，我们需要完成的工作就越繁复。</p>
<p>Dagger2 概述<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html" target="_blank" rel="external">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html</a></p>
<p>什么是 Dagger 2 以及如何使用：<br><a href="http://konmik.github.io/snorkeling-with-dagger-2.html" target="_blank" rel="external">http://konmik.github.io/snorkeling-with-dagger-2.html</a></p>
<p>Dagger 2 中的域：<br><a href="http://frogermcs.github.io/dependency-injection-with-dagger-2-custom-scopes/" target="_blank" rel="external">http://frogermcs.github.io/dependency-injection-with-dagger-2-custom-scopes/</a></p>
<p>结合使用Dagger、Espresso 和 Mockito 来完成测试：<br><a href="http://blog.sqisland.com/2015/04/dagger-2-espresso-2-mockito.html" target="_blank" rel="external">http://blog.sqisland.com/2015/04/dagger-2-espresso-2-mockito.html</a></p>
<p><em>*</em>重点关注clean CleanArchitecture of data domain presentation ,MVP使用模式<br><a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="external">https://github.com/android10/Android-CleanArchitecture</a></p>
<p>2016.3.23<br>开始搭建商品列表，并添加ButterKnif依赖。<br>走爱贝支付流程。<br>com.ta.utdid2.android.utils.AESUtils 支付宝此类，同友盟推送duplicate。<br>进而需要重新更新下，新版本的友盟推送。目前为，2.4.1-－－》更新至，2.7.0无utdid的版本</p>
<p>但是出现这个错：<br>Error:Execution failed for task ‘:app:transformClassesWithJarMergingForBaiduDebug’.</p>
<blockquote>
<p>com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: com/squareup/wire/ExtendableMessage$ExtendableBuilder.class</p>
</blockquote>
<p>2016.3.24</p>
<p>做如下操作：<br>./gradlew clean<br>./gradlew –refresh-dependencies 更新依赖</p>
<p>20:01 出UI效果图：@安卓 iOS 会员支付相关页面效果图已经上传到git，请查看<a href="http://115.28.47.160:9001/lesdo-product/lesdo-design/tree/master/iOS3.1&amp;安卓3.4" target="_blank" rel="external">http://115.28.47.160:9001/lesdo-product/lesdo-design/tree/master/iOS3.1&amp;安卓3.4</a> </p>
<p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝<br>结果：    compile ‘com.umeng:fb:5.4.0’ 依赖了 compile ‘com.umeng:message:2.4.1@aar’<br>（一万行擦尼玛啊。。尼玛老子快被玩死了。。 有木有。。还是感谢友盟大大们，说出了原因）<br>1.友盟亚杰给的解决方案：<a href="http://dev.umeng.com/feedback/android/sdk-download" target="_blank" rel="external">http://dev.umeng.com/feedback/android/sdk-download</a> 本地jar fb，然后依赖2.7的推送。<br>2.最后爱贝给了一个去掉utdid2的包（否则要新接入2.7的友盟推送，工期及长）</p>
<p>2016.3.25<br>支付进入调试阶段，弹起支付窗口。</p>
<p>2016.3.28<br>做支付的各种UI。其中包括，商品列表，支付成功、失败、异常，及会员续费弹窗。<br>调整相应接口的数据，尤其是商品列表的数据。</p>
<p>2016.3.29<br>调整支付结果显示，和支付列表UI。（支付暂告一段落，等白子出图，再做后续调整）</p>
<p>2016.3.30<br>做匿名评论相关。</p>
<p>吴一姣  10:57:15<br>@蔡鲁豫 @王康棋 @赵奎 @阿玮 git上补充了隐身功能状态下别人访问该用户个人主页时在线状态显示为未知的需求<br><a href="http://git.lesdo.cn/lesdo-product/iOS-3.1/blob/master/iOS%203.1%20%E5%92%8C%20%E5%AE%89%E5%8D%93%203.4%E9%9C%80%E6%B1%82list.xlsx" target="_blank" rel="external">http://git.lesdo.cn/lesdo-product/iOS-3.1/blob/master/iOS%203.1%20%E5%92%8C%20%E5%AE%89%E5%8D%93%203.4%E9%9C%80%E6%B1%82list.xlsx</a><br>详情：当用户处于隐身状态下时，别人访问到该用户的个人主页，显示在线时间为未知，距离正常显示。在显示在线时间的地方都显示为未知。（帖子详情、粉丝列表、关注列表、来访列表、赞我列表、聊天页）。</p>
<p>分析：</p>
<p>匿名评论的发布：    发帖处 －    发匿名帖子接口＊<br>匿名评论的显示：    所评论帖子处；－原接口加字段 isAnonymous,被回复为匿名的字段replyAnonymous ＊<br>                主态个人主页 ‘发布’中（形式与评论不同），客态个人主页不显示（isA）；<br>操作：            新版本：点击用户名或者头像，弹窗－&gt;会员介绍页；旧版本：默认的id，和头像。新旧版本统一，点击                进入默认页面。＊<br>                删除此评论，只删除匿名评论的内容；＊（删除根据 commentId和userId是否相等 &amp;&amp;isMain来判断删除的）<br>                如果会员到期，此匿名评论仍显示；如果，匿名评论的推送到来，回复是默认直接匿名，匿名也可以取消。？</p>
<p>2016.3.31</p>
<p>概述：今天出来，会员入口的展现形式。所有有头像的icon后，都加上会员icon，能显示能点击进入会员介绍页面。</p>
<p>任务分析：<br>帖子流：推荐、广场（附近贴、精选推荐、话题 TopicCardInflater）、最新、朋友圈（此处的续贴标志，有修改）、<br>我中的收藏（CollectCardRecyclerListAdapter -&gt; CommonCardRVInflater）；<br>不特殊标注的起修改位置在，CommunityTabCardInflater-&gt;CommonCardRVInflater</p>
<p>列表：顶帖列表头像（EnjoylistActivity）、评论列表头像（CardInfoAdapter L667）、<br>社区消息提醒列表头像(CardNoticeListActivity CardLNoticeListAdapter)、<br>聊天（关注、粉丝、赞我、来访）SociallistActivity ConversionListAdapter、<br>聊天列表头像(环信推送返,也就是说发送消息的时候要透传扩展字段isMember)TODO、<br>附近流和活跃流列表模式头像(主页显示未知，客态不显示)；</p>
<p>//TODO<br>单个：帖子详情头像(ko)、聊天页上方(ko)；<br>其他：匹配、求回应头像(ko)；设置</p>
<p>一娇分析：<br>帖子流头像、帖子详情头像、顶帖列表头像、评论列表头像、社区消息提醒列表头像、来访列表头像、点赞列表头像、关注列表头像、粉丝列表头像、聊天列表头像、聊天页上方、附近流和活跃流列表模式头像、匹配昵称后面、求回应流头像</p>
<p>2016.4.1<br>愚人节哦～<br>匿名评论的效果图 ，主态个人主页的隐身和会员标志位置。</p>
<p>2014.4.4<br>清明节 愿逝者灵魂安息啊门。</p>
<p>4.3号做了厄拉多塞筛选法来求素数，然后10的8次方 为2.89s左右。为了进一步减少时间。<br><a href="http://baike.baidu.com/link?url=5vBG_P3D-YKMCJTqXWSl6a4_95agPD0iZTCGSGOQJ2s3evJnaqiuecnILlWrLsTs4kixL5xUyEPbnkufb-hyWA9jq7mCavCIxc6MY0xudYG7gPUY6Helf6JAmBagzbCP9h6Sle2oX1QP34Qfbh7DgBaZHWjm-58UgWkVO7hTLUU3FOZxNkIDyCse8DCq9F1T" target="_blank" rel="external">http://baike.baidu.com/link?url=5vBG_P3D-YKMCJTqXWSl6a4_95agPD0iZTCGSGOQJ2s3evJnaqiuecnILlWrLsTs4kixL5xUyEPbnkufb-hyWA9jq7mCavCIxc6MY0xudYG7gPUY6Helf6JAmBagzbCP9h6Sle2oX1QP34Qfbh7DgBaZHWjm-58UgWkVO7hTLUU3FOZxNkIDyCse8DCq9F1T</a></p>
<p>今天做的是Miller-Rabin测试 来判断素数。<br>参考：<a href="http://www.cnblogs.com/vongang/archive/2012/03/15/2398626.html" target="_blank" rel="external">http://www.cnblogs.com/vongang/archive/2012/03/15/2398626.html</a><br>基础理论：<br>同余<br>数论中的重要概念。给定一个正整数m，如果两个整数a和b满足（a-b）能够整除m，即（a-b）/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系。</p>
<p>费马小定理：对于素数p和任意整数a，有a^p ≡ a(mod p)（同余）。反过来，满足a^ ≡ a(mod p)，p也几乎一定是素数。</p>
<p>　　伪素数：如果n是一个正整数，如果存在和n互素的正整数a满足 a^(n-1) ≡ 1(mod n)，我们说n是基于a的伪素数。如果一个数是伪素数，那么它几乎肯定是素数。</p>
<p>　　Miller-Rabin测试：不断选取不超过n-1的基b(s次)，计算是否每次都有b^(n-1) ≡ 1(mod n)，若每次都成立则n是素数，否则为合数。　<br>　　<br>　此方法的做法更适合用于判断一个数是否为素数。<br>　<br>　2016.4.5<br>　匿名帖子删除，个人主页的评论。<br>　看了一些面试简历：付九红、罗海江、姜辉、耿超 （约）<br>　                 范德农爽约<br>　<br>　2016.4.6<br>　白俊彦 边泓霖 姜辉（约）<br>　把会员入口的imageview 拆出来 用做公共类，提供设置背景图片，切换显示状态，和设置点击监听<br>　<br>　<br>　2016.4.7<br>　会员入口的接口调试 求回应未通，个人主页会员 布局，隐身、<br>　<br>　2016.4.15<br>　1.帖子评论的默认 回复他人 竖线去掉<em><br>　2.聊天的用户列表的会员标志（发送的时候就把会员字段传过去了）<br>　3.个人主页的，会员icon逻辑 </em><br>　4.擦脚印的功能调整（擦一次就默认一天）<em><br>　<br>　5.朋友圈的续icon</em>()<br>　<br>　6.帖子详情的头部会员icon大小 ＊<br>　<br>　7.支付ui<br>　8.h5调整<br>　9.设置页面的q&amp;a<br>　<br>　统计代码行数 ：<br>　前提是ruby是好的<br>　安装homebrew<br>　ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="external">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”</p>
<p>　brew install cloc<br>　<br>　cd 项目目录下<br>　cloc ./ –exclude-dir=node_modules,public/lib,public/vendor,public/build –exclude-lang=CSS<br>　<br>　<br>2016.4.20<br>聊天列表bug<br>ChatActivity.java<br>04-20 14:15:14.221  24076-24076/? E/AndroidRuntime﹕ FATAL EXCEPTION: main<br>    Process: com.android.lesdo, PID: 24076<br>    java.lang.IndexOutOfBoundsException: Invalid index 0, size is 0<br>            at java.util.ArrayList.throwIndexOutOfBoundsException(ArrayList.java:255)<br>            at java.util.ArrayList.get(ArrayList.java:308)<br>            at java.util.Collections$SynchronizedList.get(Collections.java:537)<br>            at com.easemob.chatuidemo.activity.ChatActivity$ListScrollListener.onScrollStateChanged(ChatActivity.java:1639)<br>            at android.widget.AbsListView.reportScrollStateChange(AbsListView.java:4892)<br>            at android.widget.AbsListView.onTouchUp(AbsListView.java:4393)<br>            at android.widget.AbsListView.onTouchEvent(AbsListView.java:4030)<br>            at android.widget.ListView.onTouchEvent(ListView.java:4272)<br>            at android.view.View.dispatchTouchEvent(View.java:8667)<br>            at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:2517)<br>            at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2161)<br>            at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:2523)<br>            at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2175)<br>            at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:2523)<br>            at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2175)<br>            at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:2523)<br>            at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2175)<br>            at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:2523)<br>            at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2175)<br>            at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:2523)<br>            at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2175)<br>            at com.android.internal.policy.impl.PhoneWindow$DecorView.superDispatchTouchEvent(PhoneWindow.java:2541)<br>            at com.android.internal.policy.impl.PhoneWindow.superDispatchTouchEvent(PhoneWindow.java:1812)<br>            at android.app.Activity.dispatchTouchEvent(Activity.java:2820)<br>            at com.android.internal.policy.impl.PhoneWindow$DecorView.dispatchTouchEvent(PhoneWindow.java:2498)<br>            at android.view.View.dispatchPointerEvent(View.java:8873)<br>            at android.view.ViewRootImpl$ViewPostImeInputStage.processPointerEvent(ViewRootImpl.java:4704)<br>            at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4562)<br>            at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4061)<br>            at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:4114)<br>            at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:4080)<br>            at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4217)<br>            at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:4088)<br>            at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:4274)<br>            at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4061)<br>            at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:4114)<br>            at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:4080)<br>            at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:4088)<br>            at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4061)<br>            at android.view.ViewRootImpl.deliverInputEvent(ViewRootImpl.java:6518)<br>            at android.view.ViewRootImpl.doProcessInputEvents(ViewRootImpl.java:6492)<br>            at android.view.ViewRootImpl.enqueueInputEvent(ViewRootImpl.java:6445)<br>            at android.view.ViewRootImpl$WindowInputEventReceiver.onInputEvent(ViewRootImpl.java:6698)<br>            at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185)<br>            at android.view.InputEventReceiver.nativeConsumeBatchedInputEvents(Native Method)<br>            at android.view.InputEventReceiver.consumeBatchedInputEvents(InputEventReceiver.java:176)<br>            at android.view.ViewRootImpl.doConsumeBatchedInput(ViewRootImpl.java:6636)<br>            at android.view.ViewRootImpl$ConsumeBatchedInputRunnable.run(ViewRootImpl.java:6724)<br>            at android.view.Choreographer$CallbackRecord.run(Choreographer.java:800)<br>            at android.view.Choreographer.doCallbacks(Choreographer.java:603)<br>            at android.view.Choreographer.doFrame(Choreographer.java:570)<br>            at android.view.Choreographer$FrameDisplayEventReceiver.run(Chore<br>2016.4.26<br>ui调整期间出现bug。<br>Plugin is too old, please update to a more recent version, or set ANDROID_DAILY_OVERRIDE environment variable to<br>去以下网站看下最新版本并更新：<br><a href="http://tools.android.com/tech-docs/new-build-system" target="_blank" rel="external">http://tools.android.com/tech-docs/new-build-system</a></p>
<p>5.19号 发版本3.4release</p>
<p>1.gradle中的签名信息去掉</p>
<p>2.360的需要加固才能上传市场</p>
<pre><code>下载加固的apk，签名后再上传 
签名命令：
jarsigner -verbose -keystore  /Users/wangwei/lesdo-document/keystore/keystore/key -signedjar /Users/wangwei/Desktop/generate_apk/3.4/lesdo-sanliuling.encrypted_singed.apk /Users/wangwei/Desktop/generate_apk/3.4/lesdo-sanliuling.encrypted.apk sns

zipalign命令： zipalign -v 4 /Users/wangwei/Desktop/generate_apk/3.4/lesdo-sanliuling.encrypted_singed.apk /Users/wangwei/Desktop/generate_apk/3.4/lesdo-sanliuling.encrypted_singed_zipalign.apk 

参考：http://www.cnblogs.com/wanqieddy/p/3556060.html
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/16/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-16T15:46:17+08:00" content="2016-03-16">
              2016-03-16
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/16/hexo_note/" itemprop="url">
                  Hexo搭建记录
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-16T15:46:17+08:00" content="2016-03-16">
              2016-03-16
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装初使环境"><a href="#安装初使环境" class="headerlink" title="安装初使环境"></a>安装初使环境</h2><p>1.安装git node.js,可参考其官方网站<a href="https://hexo.io/docs/" target="_blank" rel="external">Hexo</a></p>
<p>2.安装hexo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<p>注:有错,则用 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<h2 id="创建hexo文件夹"><a href="#创建hexo文件夹" class="headerlink" title="创建hexo文件夹"></a>创建hexo文件夹</h2><p>3.创建存放blog的hexo文件夹<br> 创建，如../blog</p>
<p>4.cd 到blog下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>
<p>5.cd 到blog下安装依赖包</p>
<p>传统方式(default依赖包):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>建议使用:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo --no-optional</span><br></pre></td></tr></table></figure>
<p>用传统install方式安装,deploy时可能报错,如下所示：</p>
<pre><code>&apos;hexo&apos; command shows the error message:
{ [Error: Cannot find module &apos;./build/Release/        DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; }
{ [Error: Cannot find module &apos;./build/default/        DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; }
{ [Error: Cannot find module &apos;./build/Debug/    DTraceProviderBindings&apos;] code: &apos;MODULE_NO
</code></pre><h2 id="本地查看"><a href="#本地查看" class="headerlink" title="*本地查看"></a>*本地查看</h2><p>6.现在我们已经搭建起本地的hexo博客了，<br>执行以下命令(在../blog下)，然后到浏览器输入localhost:4000看看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<h2 id="使blog和git相关"><a href="#使blog和git相关" class="headerlink" title="使blog和git相关"></a>使blog和git相关</h2><p>7.修改_config.yml文件夹下的deply发布节点信息：</p>
<pre><code>deploy:
      type: git
      repo: git@github.com:iacky/iacky.github.io.git
      branch: master
</code></pre><p>8.步骤7之前应当完成ssh的git配置，及建库操作。</p>
<p>9.修改_config.yml后，保存git配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<p>等同<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p>
<p>10.应用配置信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>等同<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>11.如deploy报错时，有二种方式可以进行处理：</p>
<p>方法一：</p>
<p>first: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo</span><br></pre></td></tr></table></figure>
<p>then:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo --no-optional --save</span><br></pre></td></tr></table></figure></p>
<p>方法二：<br>第五步用 </p>
<p><code>bash 
$ npm install hexo --no-optional</code> ,并从3开始操作(重新操作一遍);</p>
<h2 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs:"></a>Bugs:</h2><pre><code> *1. 7中的type和git中间有个 空格
 *2. hexo ERROR Deployer not found: github  
        2.1安装 npm install hexo-deployer-git --save
        2.2将deploy 的 type由github改为git
 *3.在github部署完成之后，马上访问可能出现404错误，这是正常的，（最多）等待十分钟左右就可以访问了。如果还不行，那很可能是 github 发送给你的验证邮件你没有打开看，据多方反映，验证后就没问题了。

4.如果在hexo d之后出现fatal: &apos;username.github.io&apos; does not appear to be a git repository，一是检查 repo 的名字是否合乎规范、是否含有大写字母、config.yml 中的 deploy 配置是否正确，二是把 git bash 关掉，重新打开再执行命令。
5.有的同学可能不是 IT 界的，或者对shell 命令不太了解。在要求输入密码时，你输入之后密码是不显示的，这是为了安全，并非是你没输上。
6.出现乱码的，不要使用 windows 中的「记事本」打开并编辑文件，推荐使用 sublime text，很简单。如果已经在「记事本」中编辑过，需要使用 sublime text 转码为「utf8」。
7.安装 hexo 时卡在那儿不动，很可能是网络不给力，能全局 break wall 就好了。
8.遇到什么其他的问题，不妨删除.deploy 和db.json 再重新生成试一试。

注：    我碰到其中前三个问题，其他问题为搜集整理而来。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
